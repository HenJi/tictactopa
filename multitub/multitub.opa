/*
 * OPA design pattern collection. (c) MLstate - 2011
 *
 * The Mutlitub pattern, for OPA-S3.
 * @author Mathieu Barbin
 */

/**
 * {1 Multitub}
 *
 * In this design pattern, we denote by 'tub' a new connexion. (a new client on the server)
 * For each 'tub', we have 2 sessions, one created on the server side, and one on the client side.
 *
 * The type of messages handled by theses 2 sessions are the only authorized exchanges
 * between the client and the server.
 *
 * The server part of the code does not have the right to access the DOM, or anything from
 * the client. The page is generated by the client.
 *
 * The client has 2 different kind of messages, one from the server (contract) and one
 * from some funactions which the client has generated itself.
**/

/**
 * {1 Utilisation}
 *
 * It is currently (S3) not possible to deal with too much functorization for designing
 * client-server functions constructions, because we cannot slicer function from the
 * same declaration. We are currently thinking about continuing the work on Undot for
 * functors, and maybe add a lambda-lifting pass before the slicer.
 *
 * Anyway, we would like that design pattern are distributed as a lib that people can re-use.
 * So instead of a functor, we write the code here, assuming that some types and some
 * modules are declared. Since modules in opa are recursives, and a Reorder pass assure
 * that the dependencies are satisfaid, there are no problems.
 * The user of this file should define these types and modules in a separated file.
**/

/**
 * {1 Messages}
 *
 * In this design, all events of the application are documented, and represented by
 * some messages for the sessions.
**/

/**
 * {2 Client}
**/

/**
 * The type [Multitub.C.message] should be defined in one of the file of the application.
 * It corresponds to the type representing all mesages sent by the server to the
 * client, and the messages sent by some funactions (client private messages)
 * The handler of the client will perform some actions when it receives
 * the messages, e.g. DOM modification / state modification, etc.
**/
// type Multitub.C.message = ??

/**
 * With '@abstract' we denote that user of this lib should not enter the implementation
 * of the type, but just using function exported in this file to manipulate values
 * of this type.
**/
@abstract
type Multitub.C.channel = channel(Multitub.C.message)

/**
 * {2 Server}
**/

/**
 * The type [Multitub.S.message] should be defined in one of the file of the application.
 * It corresponds to the type representing all mesages sent by the client to the
 * server. The handler of the server will perform some actions when it receives
 * the messages, e.g. state modification, some computation, and probably send back
 * some messages to the client, asynchronously.
**/
// type Multitub.S.message = ???

/**
 * When on new connexion arrives, the session on the server is created before
 * the session on the client.
 * A special message is sent just after the creation of the client-session,
 * so that the server can store it in its state for sending him some messages.
 * With '@private' we denote that this type should not be exported outside
 * of this file, and the user of the design does not manipulate it at all.
**/
@private
type Multitub.private.S.message = { message : Multitub.S.message } / { set_c_channel : Multitub.C.channel }

/**
 * With '@abstract' we denote that user of this lib should not enter the implementation
 * of the type, but just using function exported in this file to manipulate values
 * of this type.
**/
@abstract
type Multitub.S.channel = channel(Multitub.private.S.message)

/**
 * {1 Handler, components}
**/

/**
 * Once this contract is established (the types of messages), handler on the 2 sides
 * are independant, and can evoluate, without perturbing the web part of the application.
 * We could e.g. imagine have several implementations of (init, handler)
 * with the same type of messages, or parallelizing the work with different team, etc.
**/

/**
 * {2 Client}
**/

/**
 * The interface that a client for this application should implement.
 * The module of this interface should be tagged @client, and should be named
 * [Multitub_C] :
 *
 * {[
 *    @client Multitub_C : Multitub.C.interface = {{
 *      ...
 *    }}
 * ]}
**/
type Multitub.C.interface('state) = {{

  /**
   * Create the internal state of the client.
   * The initializer is not functionnal because the state of the client
   * may be imperative, there are no reason to forbid it, e.g. wrt performances
   * depending on the kind of the application.
  **/
  init : -> 'state

  /**
   * Handle messages received from the server, or from some funaction in the page.
   * Possibly, send back some messages to the server asynchronously.
   * In that case, you must use the function [Multitub.send_server] on the server channel.
  **/
  on_message : Multitub.S.channel, 'state, Multitub.C.message -> Session.instruction('state)

  /**
   * Creating the page, on the client side. By convention of the design,
   * funaction should be tagged @client, and can use one or both of channels,
   * depending on what does the funaction do.
   * Example:
   * {[
   *    @client funaction(s_channel, c_channel, event) =
   *       // depending on the event, send messages to s_channel, or c_channel
   *
   *    C = {{
   *      page(s_channel, c_channel) =
   *        ...
   *        <div id="myfunaction" onclick={funaction(s_channel, c_channel, _)}/>
   *    }}
   * ]}
   *
   * <!> The DOM element id 'multitub' is reserved by the application, and should
   * not be used.
  **/
  page : Multitub.S.channel, Multitub.C.channel -> xhtml
}}

/**
 * {2 Server}
**/

/**
 * The interface that a server for this application should implement.
 * The module of this interface should be tagged @server, and should be named
 * [Multitub_S] :
 *
 * {[
 *    @server Multitub_S : Multitub.S.interface = {{
 *      ...
 *    }}
 * ]}
**/
type Multitub.S.interface('state) = {{

  /**
   * Create the internal state of the server.
   * The initializer is not functionnal because the state of the server
   * may be imperative.
  **/
  init : -> 'state

  /**
   * Some initialization may be necessary once the server knows the client.
   * This function is not in the [Multitub.C.interface] because of the asymetrie
   * of the initialization protocol. When we create the client session, the server session
   * is known.
   *
   * This is an extra initialization for the server. In case the server does not need it,
   * simply does not change the state, as in :
   * {[
   *    on_connection(_, state) = state
   * ]}
  **/
  on_connection : Multitub.C.channel, 'state -> 'state

  /**
   * Handle messages received from the client handler, or from some funaction in the page.
   * Possibly, send back some messages to the client, in that case, you must
   * use the function [Multitub.send_client] on the client channel.
  **/
  on_message : Multitub.C.channel, 'state, Multitub.S.message -> Session.instruction('state)
}}


/**
 * {1 Implementation of the application}
**/

/**
 * {2 Client/Server}
**/

/**
 * As explained in the upper note, we cannot use fonctor on C and S.
 * So we assume that we have somewhere in the application at toplevel
 * the 2 modules, correctly tagged.
 *
 * {[
 *   @server Multitub_S : Multitub.S.interface = ...
 *   @client Multitub_C : Multitub.C.interface = ...
 * ]}
**/

/**
 * {1 Implementation of Multitub}
**/

/**
 * The state of the server session.
**/
@private
type Multitub.private.S.state('state) = {
  c_channel : option(Multitub.C.channel)
  state : 'state
}

/**
 * The state of the client session.
**/
@private
type Multitub.private.C.state('state) = {
  s_channel : Multitub.S.channel
  state : 'state
}

@public Multitub = {{

/**
 * Maping instructions for sub-state manipulation.
**/
@private session_map_instruction(map : 'a -> 'b, i) : Session.instruction('b) =
  match i : Session.instruction('a) with
  | {set = state} -> {set = map(state)}
  | {unchanged} as i
  | {stop} as i
    -> i

/**
 * {2 Client}
**/

@client @private c_init(s_channel) =
  state = Multitub_C.init()
  ~{ s_channel state } : Multitub.private.C.state

@client @private c_on_message(state, message) =
  map(internal_state) = { state with state = internal_state } : Multitub.private.C.state
  session_map_instruction(map, Multitub_C.on_message(state.s_channel, state.state, message))

/**
 * {2 Server}
**/

@server @private s_init() =
  state = Multitub_S.init()
  { c_channel = {none} ; ~state} : Multitub.private.S.state

@server @private s_on_message(state, message) =
  match message : Multitub.private.S.message with
  | { set_c_channel = c_channel } ->
    state = Multitub_S.on_connection(c_channel, state.state)
    { set = { ~state ; c_channel = { some = c_channel } } }
  | { ~message } -> (
    match state.c_channel with
    | {none} -> error("Internal error, the client has not been set yet")
    | {some = c_channel} ->
      map(internal_state) = { state with state = internal_state }
      session_map_instruction(map, Multitub_S.on_message(c_channel, state.state, message))
    )

/**
 * {2 Web}
**/

@client @private c_onload(s_channel, _) =
  c_channel = Session.make(c_init(s_channel), c_on_message)
  do send(s_channel, {set_c_channel = c_channel})
  do exec_actions( [ #multitub <- Multitub_C.page(s_channel, c_channel) ] )
  void

@server @private multitub_page() =
  s_channel = Session.make(s_init(), s_on_message)
  <>
    <div id="multitub" onready={c_onload(s_channel, _)}>
      "multitub initialization..."
    </div>
  </>

/**
 * The type Multitub.C.message should be 'abstract' (not possible with S3).
 * The server should use this function for sending
 * message to the client, and not directly the 'send' function.
**/
@both send_client(channel : Multitub.C.channel, message : Multitub.C.message) =
  send(channel, message)

/**
 * The type Multitub.S.message should be 'abstract' (not possible with S3).
 * The client should use this function for sending
 * message to the server, and not directly the 'send' function.
**/
@both send_server(channel : Multitub.S.channel, message : Multitub.S.message) =
  send(channel, { ~message })

/**
 * Creating a [one_page_server]. Use :
 * {[
 *    server = multitub("Name")
 * ]}
**/
@server one_page_server(title) = @toplevel.one_page_server(title, multitub_page)

/**
 * If you need to integrate the multitub in some url of a [simple_server]
**/
@server resource(title) =
  body = multitub_page()
  Resource.page(title, body)

}}
