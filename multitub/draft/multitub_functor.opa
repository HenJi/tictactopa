/**
 * OPA design pattern collection. (c) MLstate - 2010
 *
 * The Mutlitub pattern.
 * @author Mathieu Barbin
 */

/**
 * In this design pattern, we denote by 'tub' a new connexion.
 * For each 'tub', we have 2 session, one on the server, and one on the client.
 *
 * The type of messages handled by theses 2 session are the only authorized exchanges
 * between the client and the server.
 *
 * The server part of the code does not have the right to access the DOM, or anything from
 * the client. The page is generated by the client.
 *
 * The client has 2 different kind of messages, one from the server (contract) and one
 * from some funaction which the client has generated itself.
 *
 */

/**
 * {1 Events}
 * Public contract : just the interface of messages (event)
 */

/**
 * {2 Server}
 */

/**
 * + {a} : a first message, without argument
 * + {b:int} : a message interracting with the state of the server
 */
type S.message = { a } / { b : int }

type S.channel = channel(S.message)

/**
 * {2 Client}
 */

/**
 * In this prototype, only 1 message, a value from the server.
 */
type C.message = { value : int }

type C.channel = channel(C.message)

/**
 * {1 Handler, components}
 */

/**
 * Once this contract is established, handler on the 2 sides are independant,
 * and can be switched. We could imagine have serveral implementation of (init, handler)
 * with the corresponding type of message.
 */

/**
 * {2 Server}
 */
// FIXME: should be a module interface
type S.ARG.interface('state) = {
  init : void -> 'state
  on_message : C.channel, 'state, S.message -> Session.instruction('state)
}

/**
 * {2 Client}
 */
// FIXME: should be a module interface
type C.ARG.interface('state) = {
  init : void -> 'state
  on_message : S.channel, 'state, C.message -> Session.instruction('state)
}

/**
 * {1 Functorisation}
 */

type S.M.state('state) = {
  c_channel : option(C.channel)
  state : 'state
}

type S.M.message = { message : S.message } / { set_c_channel : C.channel }

session_map_instruction(map, i) =
  match i : Session.instruction with
  | {set = state} -> {set = map(state)}
  | {unchanged}
  | {stop} -> Magic.id(i) : Session.instruction // Fixme: do something with the typer

M(C : C.ARG.interface('c_state), S : S.ARG.interface('s_state)) = {{
  c_init(server) =
    state = C.init()
    ~{ server state }

  c_on_message(state, message) =
    map(internal_state) = { state with state = internal_state }
    session_map_instruction(map, C.on_message(state.server, state.state, message))

  s_init() =
    state = S.init()
    {c_channel = {none} ; ~state} : S.M.state('s_state)

  s_on_message(state, message) =
    match message with
    | { set_c_channel = channel } ->
      { set = { state with c_channel = { some = channel } } }
    | { ~message } -> (
      match state.c_channel with
      | {none} -> error("Internal error, the client has not been set yet")
      | {some = c_channel} ->
        map(internal_state) = { state with state = internal_state }
        session_map_instruction(map, S.on_message(c_channel, state.state, message))
    )

  client c_onload(s_channel, _) =
    c_channel = Session.make(c_init(s_channel), c_on_message)
    do send(s_channel, {set_c_channel = c_channel})
    do exec_actions( [ #main <- C.page(s_channel, c_channel) ] )
    void

  server page() =
    s_channel = Session.make(s_init(), s_on_message)
    <>
      <div id="main" onready={c_onload(s_channel, _)}>
        "default page (not yet set by the client)"
      </div>
    </>

  server one_page_server(name) = @toplevel.one_page_server(name, page)

}}
